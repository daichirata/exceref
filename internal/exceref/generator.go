package exceref

import (
	"bytes"
	"errors"
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/gobuffalo/flect"
)

type GenerateOption struct {
	GoPackageName string
	GoTagNames    []string
}

type Generator interface {
	Generate(sheet *Sheet) error
}

func BuildGenerator(lang, outDir, prefix string, option GenerateOption) Generator {
	switch lang {
	default:
		return NewGoGenerator(outDir, prefix, option)
	}
}

func NewGoGenerator(outDir, prefix string, option GenerateOption) *goGenerator {
	return &goGenerator{
		prefix: prefix,
		outDir: outDir,
		option: option,
	}
}

type goGenerator struct {
	outDir string
	prefix string
	option GenerateOption
}

func (g *goGenerator) Generate(sheet *Sheet) error {
	packageName := g.option.GoPackageName
	if packageName == "" {
		return errors.New("GenerateOption.packageName is required")
	}
	name := g.prefix + sheet.Name
	tagNames := g.option.GoTagNames

	columns := make([]*Column, 0, len(sheet.Columns))
	for _, c := range sheet.Columns {
		if c.Name == "" {
			continue
		}
		columns = append(columns, c)
	}

	src, err := g.generate(packageName, name, columns, tagNames)
	if err != nil {
		return err
	}
	if err := os.WriteFile(filepath.Join(g.outDir, name+".gen.go"), src, 0644); err != nil {
		return err
	}
	return nil
}

type GoStructDef struct {
	Name    string
	Members []*GoMemberDef
}

type GoMemberDef struct {
	Name string
	Type string
	Tag  string
}

func (g *goGenerator) generate(packageName, name string, columns []*Column, tagNames []string) ([]byte, error) {
	structDef := GoStructDef{
		Name: flect.Pascalize(flect.Singularize(name)),
	}
	for _, column := range columns {
		memberDef := &GoMemberDef{
			Name: flect.Pascalize(column.Name),
			Type: g.toGoType(column.Type),
			Tag:  g.structTag(column.Name, tagNames),
		}
		structDef.Members = append(structDef.Members, memberDef)
	}

	imports := g.collectImports(structDef.Members)

	data := map[string]any{
		"PackageName": packageName,
		"StructDef":   structDef,
		"Imports":     imports,
	}
	funcMap := map[string]any{
		"camelize":    flect.Camelize,
		"singularize": flect.Singularize,
	}

	tpl := template.Must(template.New("").Funcs(funcMap).Parse(`
// Code generated by exceref; DO NOT EDIT.
package {{ .PackageName }}

{{- if .Imports }}
import (
{{- range .Imports }}
	"{{ . }}"
{{- end }}
)
{{ end }}

type {{ .StructDef.Name }} struct {
{{- range .StructDef.Members }}
	{{ .Name }} {{ .Type }} {{ .Tag }}
{{- end }}
}
`))

	buf := new(bytes.Buffer)
	if err := tpl.Execute(buf, data); err != nil {
		return nil, err
	}
	return format.Source(buf.Bytes())
}

func (g *goGenerator) collectImports(columns []*GoMemberDef) []string {
	importSet := make(map[string]struct{})

	for _, c := range columns {
		switch c.Type {
		case "time.Time":
			importSet["time"] = struct{}{}
		case "civil.Date":
			importSet["cloud.google.com/go/civil"] = struct{}{}
		}
	}

	var imports []string
	for path := range importSet {
		imports = append(imports, path)
	}
	return imports
}

func (g *goGenerator) toGoType(t ColumnType) string {
	switch t {
	case ColumnTypeString:
		return "string"
	case ColumnTypeFloat:
		return "float64"
	case ColumnTypeInt, ColumnTypeUnixtime:
		return "int64"
	case ColumnTypeBool:
		return "bool"
	case ColumnTypeDatetime:
		return "time.Time"
	case ColumnTypeDate:
		return "civil.Date"
	default:
		return "any"
	}
}

func (g *goGenerator) structTag(name string, tagNames []string) string {
	if len(tagNames) == 0 {
		return ""
	}
	tags := make([]string, len(tagNames))
	for i, tagName := range tagNames {
		tags[i] = fmt.Sprintf(`%s:"%s"`, tagName, name)
	}
	return "`" + strings.Join(tags, " ") + "`"
}
